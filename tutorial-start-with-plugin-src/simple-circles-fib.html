<!DOCTYPE html>
<meta charset="utf-8">

<svg width="960" height="500"></svg>
<script src="//d3js.org/d3.v4.min.js"></script>
<script src="d3-foo.js"></script>
<script src="d3-fib.js"></script>

<script>
// simplified version of one from https://bl.ocks.org/mbostock/22994cc97fefaeede0d861e6815a847e

console.log('test')
var svg = d3.select("svg");

var width = svg.attr("width");
var height = svg.attr("height");

var n = d3.foo();
var fib = d3.fib();


// ToDo: figure out easier way to do this....or put it in the fib plugin?
var bins = [];
for (var i in fib){
  bins[i] = {max: fib[i], count: 0}
}


// ToDo: this can be a lot more efficient if fib.bins is an object, with record of smallest not-full bin
function getBin(c, bins){
  for(var b in bins){
    // ToDo: make sure we return 'out of bounds' if we run out of bin space

    if(bins[b].count < bins[b].max){
      bins[b].count++;
      return b;
    }
  }
}


function getY(i, bin, height, gap){

  // var midY = height/2;
  // var max = midY + i*gap;
  // var min = midY - i*gap;

  var max = height - 2*gap;
  var min = height - 2*gap - i*gap;

  return (Math.random() * (max - min) + min);
}


var circles = d3.range(n).map(function(i) {
  
   var bin = getBin(i, bins);
   var y = getY(i, bin, height, 10);
  
  return {
    x: (width/bins.length) * bin, //Math.round(Math.random() * svg.attr("width")),
    y: y //svg.attr("height")/2
  };
});


svg.selectAll("circle")
  .data(circles)
  .enter().append("circle")
    .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .attr("r", 12)
    .style("fill", "#6A8891")
    .style("stroke", "#FFF");
    

</script>

